#!/usr/bin/env python3
from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
import random
from datetime import datetime, timezone


SUPPORTED_SINGLE = ["h", "s", "sdg", "x", "z"]   # conservative: works with CUDA-Q stim target
SUPPORTED_TWO = ["cx", "cz", "swap"]            # conservative


def _ts() -> str:
    return datetime.now(timezone.utc).isoformat()


def qasm_preamble(n: int) -> list[str]:
    return [
        "OPENQASM 3.0;",
        'include "stdgates.inc";',
        f"// generated by gen_scaling_qasm.py at {_ts()}",
        f"qubit[{n}] q;",
        f"bit[{n}] c;",
        "",
    ]


def emit_measure_all(n: int) -> list[str]:
    # Explicit mapping (most robust across toolchains)
    lines: list[str] = ["barrier q;"]
    for i in range(n):
        lines.append(f"c[{i}] = measure q[{i}];")
    return lines


def write_text(path: Path, lines: list[str]) -> None:
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def gen_ghz(n: int) -> list[str]:
    lines = qasm_preamble(n)
    if n == 1:
        lines += ["h q[0];"]
    else:
        lines += ["h q[0];"]
        for i in range(1, n):
            lines.append(f"cx q[0], q[{i}];")
    lines += [""] + emit_measure_all(n)
    return lines


def gen_random_clifford(n: int, depth: int, seed: int, p_two: float = 0.30) -> list[str]:
    rng = random.Random(seed)
    lines = qasm_preamble(n)
    lines.append(f"// random Clifford-ish circuit: depth={depth} seed={seed} p_two={p_two}")
    lines.append("")

    for _ in range(depth):
        if n >= 2 and rng.random() < p_two:
            gate = rng.choice(SUPPORTED_TWO)
            a = rng.randrange(n)
            b = rng.randrange(n - 1)
            if b >= a:
                b += 1
            if gate == "cx":
                lines.append(f"cx q[{a}], q[{b}];")
            elif gate == "cz":
                lines.append(f"cz q[{a}], q[{b}];")
            elif gate == "swap":
                lines.append(f"swap q[{a}], q[{b}];")
        else:
            gate = rng.choice(SUPPORTED_SINGLE)
            a = rng.randrange(n)
            lines.append(f"{gate} q[{a}];")

    lines += [""] + emit_measure_all(n)
    return lines


@dataclass(frozen=True)
class Plan:
    ghz_min: int
    ghz_max: int
    cliff_min: int
    cliff_max: int
    cliff_step: int
    depth_mult: int
    cases: int
    seed: int


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--outdir", default="qasm3_scaling", help="Output directory for generated QASM files.")
    ap.add_argument("--ghz-min", type=int, default=2)
    ap.add_argument("--ghz-max", type=int, default=18, help="Keep <=18 if you plan TVD vs Qiskit Statevector.")
    ap.add_argument("--cliff-min", type=int, default=2)
    ap.add_argument("--cliff-max", type=int, default=18, help="Keep <=18 if you plan TVD vs Qiskit Statevector.")
    ap.add_argument("--cliff-step", type=int, default=2)
    ap.add_argument("--depth-mult", type=int, default=10, help="Depth = depth_mult * n for random Clifford circuits.")
    ap.add_argument("--cases", type=int, default=3, help="How many random Clifford circuits per n (different seeds).")
    ap.add_argument("--seed", type=int, default=1234)
    args = ap.parse_args()

    outdir = Path(args.outdir)
    outdir.mkdir(parents=True, exist_ok=True)

    plan = Plan(
        ghz_min=args.ghz_min,
        ghz_max=args.ghz_max,
        cliff_min=args.cliff_min,
        cliff_max=args.cliff_max,
        cliff_step=args.cliff_step,
        depth_mult=args.depth_mult,
        cases=args.cases,
        seed=args.seed,
    )

    written = 0

    # GHZ
    for n in range(plan.ghz_min, plan.ghz_max + 1):
        path = outdir / f"ghz_{n:02d}.qasm"
        write_text(path, gen_ghz(n))
        written += 1

    # Random Clifford (stim-friendly)
    for n in range(plan.cliff_min, plan.cliff_max + 1, plan.cliff_step):
        depth = max(1, plan.depth_mult * n)
        for k in range(plan.cases):
            seed = plan.seed + 1000 * n + k
            path = outdir / f"clifford_n{n:02d}_d{depth:03d}_s{seed}.qasm"
            write_text(path, gen_random_clifford(n, depth=depth, seed=seed))
            written += 1

    print(f"Wrote {written} QASM files into: {outdir}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
